<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hard Sudoku Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .game-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            max-width: 500px;
            width: 100%;
        }
        
        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 1px;
            margin: 20px 0;
            border: 2px solid #333;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            border: 1px solid #ccc;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .cell:hover:not(.initial) {
            background-color: #f0f0f0;
        }
        
        .cell.selected {
            background-color: #e0f7fa;
            box-shadow: inset 0 0 0 2px #26c6da;
        }
        
        .cell.initial {
            color: #333;
            background-color: #f9f9f9;
            cursor: not-allowed;
        }
        
        .cell.error {
            color: #d32f2f;
            background-color: #ffebee;
        }
        
        /* Border styling for 3x3 boxes */
        .cell:nth-child(3n) {
            border-right: 2px solid #333;
        }
        
        .cell:nth-child(9n) {
            border-right: none;
        }
        
        .row-border {
            border-bottom: 2px solid #333;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .button {
            background-color: #2196f3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: #1976d2;
        }
        
        .button.secondary {
            background-color: #757575;
        }
        
        .button.secondary:hover {
            background-color: #616161;
        }
        
        .digit-selector {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .digit {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .digit:hover {
            background-color: #bbdefb;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }
        
        .status.success {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        
        .status.error {
            background-color: #ffebee;
            color: #c62828;
        }
        
        .timer {
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
        }
        
        .difficulty {
            font-weight: bold;
            color: #d32f2f;
            margin-bottom: 15px;
        }
        
        @media (max-width: 500px) {
            .cell {
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
            
            .digit {
                width: 25px;
                height: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Sudoku</h1>
        <div class="difficulty">Difficulty: Hard</div>
        <div class="timer">Time: 00:00</div>
        <div class="controls">
            <button id="new-game" class="button">New Game</button>
            <button id="check" class="button secondary">Check Solution</button>
            <button id="solve" class="button secondary">Solve</button>
        </div>
        <div id="sudoku-board" class="sudoku-board"></div>
        <div class="digit-selector">
            <div class="digit" data-digit="1">1</div>
            <div class="digit" data-digit="2">2</div>
            <div class="digit" data-digit="3">3</div>
            <div class="digit" data-digit="4">4</div>
            <div class="digit" data-digit="5">5</div>
            <div class="digit" data-digit="6">6</div>
            <div class="digit" data-digit="7">7</div>
            <div class="digit" data-digit="8">8</div>
            <div class="digit" data-digit="9">9</div>
        </div>
        <div id="status" class="status" style="display: none;"></div>
    </div>
    
    <script>
        class SudokuGame {
            constructor() {
                this.board = Array(9).fill().map(() => Array(9).fill(0));
                this.solution = Array(9).fill().map(() => Array(9).fill(0));
                this.initialCells = new Set();
                this.selectedCell = null;
                this.timerInterval = null;
                this.seconds = 0;
                
                this.boardElement = document.getElementById('sudoku-board');
                this.statusElement = document.getElementById('status');
                this.timerElement = document.querySelector('.timer');
                
                this.initializeBoard();
                this.setupEventListeners();
                this.newGame();
                this.startTimer();
            }
            
            initializeBoard() {
                this.boardElement.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Add border styling for 3x3 boxes
                        if (row === 2 || row === 5) {
                            cell.classList.add('row-border');
                        }
                        
                        this.boardElement.appendChild(cell);
                    }
                }
            }
            
            setupEventListeners() {
                // Cell selection
                this.boardElement.addEventListener('click', (e) => {
                    if (e.target.classList.contains('cell') && !e.target.classList.contains('initial')) {
                        if (this.selectedCell) {
                            this.selectedCell.classList.remove('selected');
                        }
                        this.selectedCell = e.target;
                        this.selectedCell.classList.add('selected');
                    }
                });
                
                // Digit selection
                document.querySelectorAll('.digit').forEach(digit => {
                    digit.addEventListener('click', (e) => {
                        if (this.selectedCell) {
                            const row = parseInt(this.selectedCell.dataset.row);
                            const col = parseInt(this.selectedCell.dataset.col);
                            const value = parseInt(e.target.dataset.digit);
                            
                            this.board[row][col] = value;
                            this.selectedCell.textContent = value;
                            
                            // Check for conflicts
                            if (this.hasConflict(row, col, value)) {
                                this.selectedCell.classList.add('error');
                            } else {
                                this.selectedCell.classList.remove('error');
                            }
                            
                            // Check if the puzzle is complete
                            if (this.isBoardFilled() && !this.hasAnyConflicts()) {
                                this.showStatus('Congratulations! Puzzle solved!', 'success');
                                this.stopTimer();
                            }
                        }
                    });
                });
                
                // Keyboard input
                document.addEventListener('keydown', (e) => {
                    if (this.selectedCell && !this.selectedCell.classList.contains('initial')) {
                        const row = parseInt(this.selectedCell.dataset.row);
                        const col = parseInt(this.selectedCell.dataset.col);
                        
                        if (e.key >= '1' && e.key <= '9') {
                            const value = parseInt(e.key);
                            this.board[row][col] = value;
                            this.selectedCell.textContent = value;
                            
                            if (this.hasConflict(row, col, value)) {
                                this.selectedCell.classList.add('error');
                            } else {
                                this.selectedCell.classList.remove('error');
                            }
                            
                            if (this.isBoardFilled() && !this.hasAnyConflicts()) {
                                this.showStatus('Congratulations! Puzzle solved!', 'success');
                                this.stopTimer();
                            }
                        } else if (e.key === 'Backspace' || e.key === 'Delete') {
                            this.board[row][col] = 0;
                            this.selectedCell.textContent = '';
                            this.selectedCell.classList.remove('error');
                        }
                    }
                });
                
                // Control buttons
                document.getElementById('new-game').addEventListener('click', () => {
                    this.newGame();
                });
                
                document.getElementById('check').addEventListener('click', () => {
                    if (this.hasAnyConflicts()) {
                        this.showStatus('There are errors in your solution!', 'error');
                    } else if (!this.isBoardFilled()) {
                        this.showStatus('Board is not completely filled!', 'error');
                    } else {
                        this.showStatus('Great job! Your solution is correct!', 'success');
                        this.stopTimer();
                    }
                });
                
                document.getElementById('solve').addEventListener('click', () => {
                    this.solveBoard();
                });
            }
            
            hasConflict(row, col, value) {
                // Check row
                for (let c = 0; c < 9; c++) {
                    if (c !== col && this.board[row][c] === value) {
                        return true;
                    }
                }
                
                // Check column
                for (let r = 0; r < 9; r++) {
                    if (r !== row && this.board[r][col] === value) {
                        return true;
                    }
                }
                
                // Check 3x3 box
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        const currRow = boxRow + r;
                        const currCol = boxCol + c;
                        if ((currRow !== row || currCol !== col) && this.board[currRow][currCol] === value) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            hasAnyConflicts() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const value = this.board[row][col];
                        if (value !== 0) {
                            // Temporarily set cell to 0 to check against other cells
                            this.board[row][col] = 0;
                            if (this.hasConflict(row, col, value)) {
                                this.board[row][col] = value; // Reset the value
                                return true;
                            }
                            this.board[row][col] = value; // Reset the value
                        }
                    }
                }
                return false;
            }
            
            isBoardFilled() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            showStatus(message, type) {
                this.statusElement.textContent = message;
                this.statusElement.className = `status ${type}`;
                this.statusElement.style.display = 'block';
                
                setTimeout(() => {
                    this.statusElement.style.display = 'none';
                }, 3000);
            }
            
            generateSudoku(difficulty) {
                // Generate a solved sudoku puzzle
                this.generateSolvedBoard();
                
                // Store the solution
                this.solution = JSON.parse(JSON.stringify(this.board));
                
                // Remove numbers based on difficulty
                let cellsToRemove;
                switch (difficulty) {
                    case 'easy':
                        cellsToRemove = 35;
                        break;
                    case 'medium':
                        cellsToRemove = 45;
                        break;
                    case 'hard':
                        cellsToRemove = 55;
                        break;
                    default:
                        cellsToRemove = 55; // Hard by default
                }
                
                // Remove cells randomly but ensure the puzzle is still uniquely solvable
                const cellIndices = [];
                for (let i = 0; i < 81; i++) {
                    cellIndices.push(i);
                }
                
                // Shuffle array
                for (let i = cellIndices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cellIndices[i], cellIndices[j]] = [cellIndices[j], cellIndices[i]];
                }
                
                for (let i = 0; i < cellsToRemove; i++) {
                    const index = cellIndices[i];
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    this.board[row][col] = 0;
                }
            }
            
            generateSolvedBoard() {
                // Initialize with zeros
                this.board = Array(9).fill().map(() => Array(9).fill(0));
                
                // Solve the board starting from empty
                this.solveSudoku(this.board);
                
                // Shuffle the board a bit for variety
                this.shuffleBoard();
            }
            
            shuffleBoard() {
                // Perform some row and column swaps within the same 3x3 block
                // to maintain a valid solution
                for (let i = 0; i < 10; i++) {
                    const block = Math.floor(Math.random() * 3);
                    const row1 = block * 3 + Math.floor(Math.random() * 3);
                    let row2 = block * 3 + Math.floor(Math.random() * 3);
                    while (row1 === row2) {
                        row2 = block * 3 + Math.floor(Math.random() * 3);
                    }
                    
                    // Swap rows
                    [this.board[row1], this.board[row2]] = [this.board[row2], this.board[row1]];
                    
                    const col1 = block * 3 + Math.floor(Math.random() * 3);
                    let col2 = block * 3 + Math.floor(Math.random() * 3);
                    while (col1 === col2) {
                        col2 = block * 3 + Math.floor(Math.random() * 3);
                    }
                    
                    // Swap columns
                    for (let row = 0; row < 9; row++) {
                        [this.board[row][col1], this.board[row][col2]] = 
                        [this.board[row][col2], this.board[row][col1]];
                    }
                }
            }
            
            solveSudoku(board) {
                const emptyCell = this.findEmptyCell(board);
                if (!emptyCell) {
                    return true; // Puzzle solved
                }
                
                const [row, col] = emptyCell;
                const numbers = this.getRandomNumberArray();
                
                for (const num of numbers) {
                    if (this.isValidPlacement(board, row, col, num)) {
                        board[row][col] = num;
                        
                        if (this.solveSudoku(board)) {
                            return true;
                        }
                        
                        board[row][col] = 0; // Backtrack
                    }
                }
                
                return false;
            }
            
            getRandomNumberArray() {
                const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                for (let i = numbers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                }
                return numbers;
            }
            
            findEmptyCell(board) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === 0) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }
            
            isValidPlacement(board, row, col, num) {
                // Check row
                for (let c = 0; c < 9; c++) {
                    if (board[row][c] === num) {
                        return false;
                    }
                }
                
                // Check column
                for (let r = 0; r < 9; r++) {
                    if (board[r][col] === num) {
                        return false;
                    }
                }
                
                // Check 3x3 box
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        if (board[boxRow + r][boxCol + c] === num) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            newGame() {
                // Reset game state
                this.initialCells.clear();
                if (this.selectedCell) {
                    this.selectedCell.classList.remove('selected');
                    this.selectedCell = null;
                }
                
                // Generate new puzzle
                this.generateSudoku('hard');
                
                // Update UI
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.className = 'cell';
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.board[row][col] !== 0) {
                        cell.textContent = this.board[row][col];
                        cell.classList.add('initial');
                        this.initialCells.add(`${row}-${col}`);
                    } else {
                        cell.textContent = '';
                    }
                });
                
                // Reset timer
                this.resetTimer();
                this.startTimer();
                
                this.statusElement.style.display = 'none';
            }
            
            solveBoard() {
                // Display the solution
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    cell.textContent = this.solution[row][col];
                    this.board[row][col] = this.solution[row][col];
                    cell.classList.remove('error');
                });
                
                this.showStatus('Puzzle solved!', 'success');
                this.stopTimer();
            }
            
            startTimer() {
                this.stopTimer();
                this.timerInterval = setInterval(() => {
                    this.seconds++;
                    const minutes = Math.floor(this.seconds / 60);
                    const secs = this.seconds % 60;
                    this.timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            resetTimer() {
                this.stopTimer();
                this.seconds = 0;
                this.timerElement.textContent = 'Time: 00:00';
            }
        }
        
        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SudokuGame();
        });
        
        // Start the game immediately
        const game = new SudokuGame();
    </script>
</body>
</html>